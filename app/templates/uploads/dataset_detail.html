{% extends 'base.html' %}

{% block title %}Dataset ‚Äì {{ dataset.name }}{% endblock %}

{% block content %}
<div class="dashboard-header mb-4">
  <h1 class="mb-2">{{ dataset.name }}</h1>
  {% if dataset.description %}
    <p class="text-secondary">{{ dataset.description }}</p>
  {% endif %}

  <!-- Patient Information -->
  {% if dataset.patient_name %}
    <div class="card bg-dark text-light p-3 mb-3">
      <h5 class="mb-3">Patient Information</h5>
      <div class="row">
        <div class="col-md-6">
          <p class="mb-1"><strong>Name:</strong> {{ dataset.patient_name }}</p>
          <p class="mb-1"><strong>ID:</strong> {{ dataset.patient_id }}</p>
        </div>
        <div class="col-md-6">
          <p class="mb-1"><strong>Date of Birth:</strong> {{ dataset.patient_dob.strftime('%Y-%m-%d') if dataset.patient_dob }}</p>
          <p class="mb-1"><strong>Gender:</strong> {{ dataset.patient_gender }}</p>
        </div>
      </div>
    </div>
  {% endif %}

  <!-- Scan Information -->
  {% if dataset.scan_type %}
    <div class="card bg-dark text-light p-3 mb-3">
      <h5 class="mb-3">Scan Information</h5>
      <div class="row">
        <div class="col-md-6">
          <p class="mb-1"><strong>Type:</strong> {{ dataset.scan_type }}</p>
          <p class="mb-1"><strong>Date:</strong> {{ dataset.scan_date.strftime('%Y-%m-%d') if dataset.scan_date }}</p>
        </div>
        <div class="col-md-6">
          <p class="mb-1"><strong>Series Number:</strong> {{ dataset.scan_series_number }}</p>
          {% if dataset.scan_description %}
            <p class="mb-1"><strong>Description:</strong> {{ dataset.scan_description }}</p>
          {% endif %}
        </div>
      </div>
    </div>
  {% endif %}

  <p>Status: <span class="fw-bold text-info">{{ dataset.tags }}</span></p>
  <div id="image-controls" class="d-flex flex-row align-items-center gap-3 mt-3" style="background:#23272b; border-radius:8px; padding:12px;">
    <label class="text-light mb-0" for="brightness-slider">Brightness</label>
    <input type="range" id="brightness-slider" min="-100" max="100" value="0" style="width:120px;">
    <span id="brightness-value" class="text-light">0</span>
    <label class="text-light mb-0 ms-3" for="contrast-slider">Contrast</label>
    <input type="range" id="contrast-slider" min="-100" max="100" value="0" style="width:120px;">
    <span id="contrast-value" class="text-light">0</span>
  </div>
  <div id="drawing-tools" class="d-flex flex-row align-items-center gap-3 mt-3" style="background:#23272b; border-radius:8px; padding:12px;">
    <button class="btn btn-outline-light btn-sm" id="tool-pen" title="Freehand">‚úèÔ∏è Pen</button>
    <button class="btn btn-outline-light btn-sm" id="tool-rect" title="Rectangle">‚ñ≠ Rect</button>
    <button class="btn btn-outline-light btn-sm" id="tool-circle" title="Circle">‚óØ Circle</button>
    <button class="btn btn-outline-light btn-sm" id="tool-eraser" title="Eraser">üßΩ Eraser</button>
    <label class="text-light mb-0 ms-3" for="brush-size">Brush Size</label>
    <input type="range" id="brush-size" min="1" max="30" value="5" style="width:100px;">
    <span id="brush-size-value" class="text-light">5</span>
    <label class="text-light mb-0 ms-3" for="brush-color">Color</label>
    <input type="color" id="brush-color" value="#00ff00" style="width: 30px; height: 30px;">
    <button class="btn btn-outline-warning btn-sm ms-3" id="tool-undo" title="Undo">‚Ü©Ô∏è Undo</button>
    <button class="btn btn-outline-warning btn-sm" id="tool-redo" title="Redo">‚Ü™Ô∏è Redo</button>
    <button class="btn btn-outline-danger btn-sm" id="tool-clear" title="Clear">üóëÔ∏è Clear</button>
  </div>
</div>

<!-- Editor Section -->
<div class="editor-container d-flex flex-row justify-content-between align-items-center gap-3 flex-wrap w-100 overflow-hidden my-4">
    <canvas id="image-canvas2" style="position:relative; top:0; left:0; z-index:1; width:100%; height:100%;"></canvas>

  <div class="editor-toolbar mb-2"></div>
  <div class="editor-wrapper card bg-secondary bg-gradient p-3" style="position:relative;">
    <canvas id="image-canvas" style="position:absolute; top:0; left:0; z-index:1; width:100%; height:100%;"></canvas>
    <canvas id="annotation-canvas" style="position:absolute; top:0; left:0; z-index:2; width:100%; height:100%;"></canvas>
  </div>
</div>

<p class="text-center text-light">
  Image <span id="current-index">1</span> of {{ files|length }}
  {% if files and files[0].mime == 'application/dicom' %}
  | Slice <span id="current-slice">1</span> of <span id="total-slices">1</span>
  {% endif %}
</p>

<!-- Slim, professional toolbar -->
<div class="d-flex flex-wrap justify-content-center align-items-center gap-3 py-2 mb-3" style="background: #23272b; border-radius: 0.5rem;">
  <div class="btn-group me-2" role="group" aria-label="Navigation">
    <button id="prev" class="btn btn-outline-light btn-sm" title="Previous Image">‚óÄ</button>
    <button id="next" class="btn btn-outline-light btn-sm" title="Next Image">‚ñ∂</button>
    <button id="prev-slice" class="btn btn-outline-light btn-sm" title="Previous Slice">‚Üë</button>
    <button id="next-slice" class="btn btn-outline-light btn-sm" title="Next Slice">‚Üì</button>
  </div>
  <div class="d-flex align-items-center gap-2">
    <label class="text-light mb-0" for="contour-method" style="font-size: 0.95em;">Contour:</label>
    <select id="contour-method" class="form-select form-select-sm w-auto">
      <option value="adaptive">Adaptive</option>
      <option value="canny">Canny</option>
      <option value="manual">Manual Threshold</option>
      <option value="otsu">Otsu</option>
    </select>
  </div>
  <div class="d-flex align-items-center gap-2">
    <label class="text-light mb-0" for="contour-threshold" style="font-size: 0.95em;">Threshold:</label>
    <input type="range" id="contour-threshold" min="0" max="255" value="50" class="form-range w-auto" style="width:120px;">
    <span id="contour-threshold-value" class="text-light ms-1" style="font-size: 0.95em;">50</span>
  </div>
  <div class="d-flex align-items-center gap-2">
    <label class="text-light mb-0" for="interpolation-slices" style="font-size: 0.95em;">Interp. Slices:</label>
    <input type="number" id="interpolation-slices" min="0" max="10" value="0" class="form-control form-control-sm" style="width:60px;">
  </div>
  <button id="toggle-contours" class="btn btn-outline-info btn-sm ms-2">Show Contours</button>
  <button id="toggle-interpolation" class="btn btn-outline-warning btn-sm ms-2">Enable Interpolation</button>
  <button id="reconstruct-volume" class="btn btn-outline-success btn-sm ms-2">Reconstruct Volume</button>
</div>
<div class="d-flex justify-content-center my-3">
      <input type="range" id="image-slider" class="form-range" style="width:80%; max-width:500px;"
             min="1" max="{{ files|length }}" value="1">
    </div>

<!-- Edit Controls -->
<div id="edit-controls" class="mt-4">
  <form id="batch-filter-form" method="POST" action="{{ url_for('processing.batch_apply', ds_id=dataset.id) }}" class="d-flex flex-wrap gap-2 justify-content-center mb-3">
    {% for name in filter_names %}
      <button type="submit" name="filter_name" value="{{ name }}" class="btn btn-outline-info">{{ name }}</button>
    {% endfor %}
  </form>
  <div class="d-flex gap-2 justify-content-center align-items-center mb-2">
    <a href="{{ url_for('processing.batch_undo', ds_id=dataset.id) }}" class="btn btn-outline-warning">Undo All</a>
    <a href="{{ url_for('processing.batch_reset', ds_id=dataset.id) }}" class="btn btn-outline-danger">Reset All</a>
    <a href="{{ url_for('processing.batch_download', ds_id=dataset.id) }}" class="btn btn-outline-success">Download All</a>
    {% if files and files[0].mime == 'application/dicom' %}
    <button id="check-structure" class="btn btn-outline-info">Check Dataset Structure</button>
    {% endif %}
  </div>
  {% if processes %}
    <p class="mt-3"><strong>Applied Filters:</strong> <span class="text-info">{{ processes | join(' ‚Üí ') }}</span></p>
  {% endif %}
  <div id="dataset-structure-info" class="mt-3 text-center" style="display: none;">
      <div class="spinner-border text-info" role="status" style="display: none;">
          <span class="visually-hidden">Loading...</span>
      </div>
  </div>
</div>

<!-- 3D Viewer Section -->
<div class="mt-4">
    <div id="mesh-viewer" style="width: 100%; height: 500px; background: #111; border-radius: 0.5rem;"></div>
    <div class="d-flex flex-wrap justify-content-center gap-3 mt-2">
        <div class="d-flex align-items-center gap-2">
            <button id="show-mesh" class="btn btn-outline-info btn-sm">Show Mesh</button>
            <button id="reset-camera" class="btn btn-outline-light btn-sm">Reset View</button>
            <button id="export-stl" class="btn btn-outline-success btn-sm">Export STL</button>
        </div>
        <div class="d-flex align-items-center gap-2">
            <label class="text-light mb-0" for="mesh-opacity" style="font-size: 0.95em;">Opacity:</label>
            <input type="range" id="mesh-opacity" min="0" max="100" value="100" class="form-range" style="width:100px;">
        </div>
        <div class="d-flex align-items-center gap-2">
            <label class="text-light mb-0" for="mesh-color" style="font-size: 0.95em;">Color:</label>
            <select id="mesh-color" class="form-select form-select-sm" style="width:120px;">
                <option value="blue">Blue</option>
                <option value="red">Red</option>
                <option value="green">Green</option>
                <option value="yellow">Yellow</option>
                <option value="purple">Purple</option>
            </select>
        </div>
        <div class="d-flex align-items-center gap-2">
            <label class="text-light mb-0" for="render-mode" style="font-size: 0.95em;">Mode:</label>
            <select id="render-mode" class="form-select form-select-sm" style="width:120px;">
                <option value="solid">Solid</option>
                <option value="wireframe">Wireframe</option>
                <option value="points">Points</option>
            </select>
        </div>
    </div>
    <div class="d-flex flex-wrap justify-content-center gap-3 mt-2">
        <div class="d-flex align-items-center gap-2">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="smooth-volume">
                <label class="form-check-label text-light" for="smooth-volume">Smooth Volume</label>
            </div>
        </div>
        <div class="d-flex align-items-center gap-2">
            <label class="text-light mb-0" for="smooth-factor" style="font-size: 0.95em;">Smooth Factor:</label>
            <input type="range" id="smooth-factor" min="0" max="200" value="100" class="form-range" style="width:100px;">
        </div>
        <div class="d-flex align-items-center gap-2">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="fill-holes">
                <label class="form-check-label text-light" for="fill-holes">Fill Holes</label>
            </div>
        </div>
    </div>
</div>

<script type="module">
import { CursorManager } from "{{ url_for('static', filename='js/editor/CursorManager.js') }}";

document.addEventListener('DOMContentLoaded', function() {
    // Assign Jinja2 variables to JS constants at the top
    const dsId = {{ dataset.id|tojson }};
    const fileIds = {{ files|default([])|map(attribute='id')|list|tojson }};
    console.log(fileIds)
    let idx = 0;
    const currentIndexEl = document.getElementById('current-index');
    const currentSliceEl = document.getElementById('current-slice');
    const totalSlicesEl = document.getElementById('total-slices');
    const total = fileIds.length;
    const toolbarEl = document.querySelector('.editor-toolbar');
    const imageCanvas = document.getElementById('image-canvas');
    const imageCanvas2 = document.getElementById('image-canvas2');
    const annotationCanvas = document.getElementById('annotation-canvas');
    const filterForm = document.getElementById('batch-filter-form');
    let contoursVisible = false;
    let currentTool = 'pen';
    let brushSize = 5;
    let brushColor = '#00ff00';
    let drawing = false;
    let startX = 0, startY = 0;
    let lastX = 0, lastY = 0;
    let interpolationEnabled = false;
    let interpolationSlices = 0;
    let annotationHistory = [];
    window.annotationHistory = annotationHistory;
    let redoStack = [];

    function loadImageToCanvas(imageUrl, imageCanvas, annotationCanvas, callback) {
        console.log('Loading image from URL:', imageUrl);  // Debug log
        const img = new window.Image();
        img.onload = function() {
            console.log('Image loaded successfully');  // Debug log
            // Set wrapper size to match image
            const wrapper = imageCanvas.parentElement;
            wrapper.style.width = img.width + 'px';
            wrapper.style.height = img.height + 'px';

            // Set canvas pixel size to match image
            imageCanvas.width = img.width;
            imageCanvas.height = img.height;
            imageCanvas2.width = img.width;
            imageCanvas2.height = img.height;
            annotationCanvas.width = img.width;
            annotationCanvas.height = img.height;

            imageCanvas.style.width = annotationCanvas.style.width = img.width + 'px';
            imageCanvas.style.height = annotationCanvas.style.height = img.height + 'px';
            imageCanvas2.style.width = annotationCanvas.style.width = img.width + 'px';
            imageCanvas2.style.height = annotationCanvas.style.height = img.height + 'px';

            imageCanvas.getContext('2d').clearRect(0, 0, img.width, img.height);
            imageCanvas.getContext('2d').drawImage(img, 0, 0);
            imageCanvas2.getContext('2d').clearRect(0, 0, img.width, img.height);
            imageCanvas2.getContext('2d').drawImage(img, 0, 0);
            annotationCanvas.getContext('2d').clearRect(0, 0, img.width, img.height);

            loadPastAnnotations();

            

            if (callback) callback();
        };
        img.onerror = function(error) {
            console.error('Failed to load image:', imageUrl, error);  // Debug log
            // Show error message on canvas
            const ctx = imageCanvas.getContext('2d');
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.fillStyle = '#dc3545';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Failed to load image', imageCanvas.width/2, imageCanvas.height/2);
        };
        img.src = imageUrl;
    }
    const slider = document.getElementById('image-slider');
                    
    if (true) {
        async function fetchDicomInfo(fileId) {
            try {
                const response = await fetch(`{{ url_for('processing.dicom_info', file_id=0) }}`.replace('0', fileId));
                if (!response.ok) throw new Error('Failed to fetch DICOM info');
                const data = await response.json();
                if (data.error) throw new Error(data.error);
                return data;
            } catch (error) {
                console.error('Error fetching DICOM info:', error);
                return { total_slices: 1 };
            }
        }
        
        slider.addEventListener('input', () => {console.log(slider.value); idx = +slider.value - 1;if (currentSliceEl) currentSliceEl.textContent = idx + 1; updateImage(); });
        async function updateImage() {
            const imageUrl = `{{ url_for('processing.image', file_id=0) }}`.replace('0', fileIds[idx]);
            console.log('Updating image with URL:', imageUrl);  // Debug log
            currentIndexEl.textContent = idx + 1;
            toolbarEl.innerHTML = '';
            slider.value = idx + 1;
            
            // Check if the first file is a DICOM file by checking its extension
            const firstFile = {{ files[0].path|tojson|safe }};
            const isDicom = firstFile.toLowerCase().endsWith('.dcm');
            console.log('First file:', firstFile);  // Debug log
            console.log('Is DICOM:', isDicom);  // Debug log
            
            if (isDicom) {
                // Fetch DICOM info for the current file
                const dicomInfo = await fetchDicomInfo(fileIds[idx]);
                if (totalSlicesEl) totalSlicesEl.textContent = dicomInfo.total_slices || total;
                if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            }
            
            // Load image and reset annotation canvas
            loadImageToCanvas(imageUrl, imageCanvas, annotationCanvas, async function() {
                // Set up drawing tools on annotationCanvas only
                const imageManager = {
                    getContext: () => annotationCanvas.getContext('2d'),
                    getCanvas: () => annotationCanvas,
                    getRegions: () => [], // You can implement region tracking if needed
                    addRegion: () => {},
                };
                const cursorManager = CursorManager(imageManager);
                toolbarEl.innerHTML = ""; // Clear previous buttons
                //toolbarEl.appendChild(cursorManager.getElement());
                cursorManager.bindCanvas(annotationCanvas);

                // --- Draw contours ---
                if (contoursVisible) {
                    await drawExtendedContours(idx, annotationCanvas);
                }
            });
        }

        async function drawExtendedContours(idx, annotationCanvas) {
            const ctx = annotationCanvas.getContext('2d');
            ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            const method = document.getElementById('contour-method')?.value || 'adaptive';
            const threshold = document.getElementById('contour-threshold')?.value || 50;

            // Helper to fetch contours
            async function fetchContours(sliceIdx) {
                if (sliceIdx < 0 || sliceIdx >= fileIds.length) return null;
                let url = `/process/contours/${fileIds[sliceIdx]}?method=${method}`;
                if (method === 'manual') url += `&threshold=${threshold}`;
                const response = await fetch(url);
                const data = await response.json();
                return data.contours;
            }

            // Helper to draw contours
            function drawContours(contours, color, width, alpha=1.0) {
                if (!contours) return;
                ctx.save();
                ctx.strokeStyle = color;
                ctx.globalAlpha = alpha;
                ctx.lineWidth = width;
                contours.forEach(contour => {
                    if (contour.length < 2) return;
                    ctx.beginPath();
                    ctx.moveTo(contour[0][0], contour[0][1]);
                    for (let i = 1; i < contour.length; i++) {
                        ctx.lineTo(contour[i][0], contour[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }

            // Fetch contours for current and adjacent slices
            const prevContours = await fetchContours(idx - 1);
            const currentContours = await fetchContours(idx);
            const nextContours = await fetchContours(idx + 1);

            // Draw interpolated contours if enabled
            if (interpolationEnabled && interpolationSlices > 0) {
                if (prevContours && currentContours) {
                    // Interpolate between previous and current slice
                    const response = await fetch('/process/interpolate-contours', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contour1: prevContours[0],
                            contour2: currentContours[0],
                            num_slices: interpolationSlices
                        })
                    });
                    const data = await response.json();
                    data.interpolated.forEach((contour, i) => {
                        const alpha = 0.3 * (1 - (i + 1) / (interpolationSlices + 1));
                        drawContours([contour], 'rgba(0,0,255,0.5)', 1, alpha);
                    });
                }
                if (currentContours && nextContours) {
                    // Interpolate between current and next slice
                    const response = await fetch('/process/interpolate-contours', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contour1: currentContours[0],
                            contour2: nextContours[0],
                            num_slices: interpolationSlices
                        })
                    });
                    const data = await response.json();
                    data.interpolated.forEach((contour, i) => {
                        const alpha = 0.3 * ((i + 1) / (interpolationSlices + 1));
                        drawContours([contour], 'rgba(255,0,0,0.5)', 1, alpha);
                    });
                }
            }

            // Draw the main contours
            drawContours(prevContours, 'rgba(0,0,255,0.5)', 1, 0.5);
            drawContours(nextContours, 'rgba(255,0,0,0.5)', 1, 0.5);
            drawContours(currentContours, 'lime', 2, 1.0);
        }

        // Handle slice navigation
        if (document.getElementById('prev-slice')) {
            document.getElementById('prev-slice').addEventListener('click', function() {
                if (idx > 0) {
                    idx--;
                    if (currentSliceEl) currentSliceEl.textContent = idx + 1;
                    console.log('Previous slice:', idx + 1);  // Debug log
                    updateImage();
                }
            });

            document.getElementById('next-slice').addEventListener('click', function() {
                if (idx < total - 1) {
                    idx++;
                    if (currentSliceEl) currentSliceEl.textContent = idx + 1;
                    console.log('Next slice:', idx + 1);  // Debug log
                    updateImage();
                }
            });
        }

        document.getElementById('prev').addEventListener('click', function() {
            idx = (idx - 1 + total) % total;
            if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            updateImage();
        });

        document.getElementById('next').addEventListener('click', function() {
            idx = (idx + 1) % total;
            if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            updateImage();
        });

        // Handle filter form submission
        filterForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData();
            const filterName = e.submitter.value; // Get the value from the clicked button
            formData.append('filter_name', filterName);
            
            fetch(this.action, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the processes list if it exists
                    const processesEl = document.querySelector('#edit-controls p');
                    if (processesEl) {
                        processesEl.innerHTML = `<strong>Applied Filters:</strong> ${data.processes.join(' ‚Üí ')}`;
                    }
                    
                    // Add a timestamp to force image reload
                    const timestamp = new Date().getTime();
                    const imageUrl = `{{ url_for('processing.image', file_id=0) }}`.replace('0', fileIds[idx]);
                    const finalUrl = `${imageUrl}?t=${timestamp}`;
                    
                    // Reload the current image to show the applied filter
                    loadImageToCanvas(finalUrl, imageCanvas, annotationCanvas, function() {
                        // Set up drawing tools on annotationCanvas only
                        const imageManager = {
                            getContext: () => annotationCanvas.getContext('2d'),
                            getCanvas: () => annotationCanvas,
                            getRegions: () => [], // You can implement region tracking if needed
                            addRegion: () => {},
                        };
                        const cursorManager = CursorManager(imageManager);
                        toolbarEl.innerHTML = ""; // Clear previous buttons
                        toolbarEl.appendChild(cursorManager.getElement());
                        cursorManager.bindCanvas(annotationCanvas);
                    });
                } else {
                    console.error('Failed to apply filter:', data.message);
                }
            })
            .catch(error => {
                console.error('Error applying filter:', error);
            });
        });

        // Add dataset structure check
        const checkStructureBtn = document.getElementById('check-structure');
        if (checkStructureBtn) {
            checkStructureBtn.addEventListener('click', async function() {
                const infoDiv = document.getElementById('dataset-structure-info');
                const spinner = infoDiv.querySelector('.spinner-border');
                
                try {
                    // Show loading spinner
                    infoDiv.style.display = 'block';
                    spinner.style.display = 'inline-block';
                    infoDiv.innerHTML = ''; // Clear previous content
                    infoDiv.appendChild(spinner);
                    
                    const response = await fetch(`{{ url_for('processing.dataset_info', ds_id=dataset.id) }}`);
                    const data = await response.json();
                    
                    // Hide spinner
                    spinner.style.display = 'none';
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to fetch dataset info');
                    }
                    
                    if (data.error) {
                        infoDiv.innerHTML = `
                            <div class="card bg-danger text-light p-3">
                                <h5>Error</h5>
                                <p>${data.error}</p>
                                ${data.file_path ? `<p class="small">File path: ${data.file_path}</p>` : ''}
                            </div>
                        `;
                        return;
                    }
                    
                    infoDiv.innerHTML = `
                        <div class="card bg-secondary text-light p-3">
                            <h5>Dataset Structure Information</h5>
                            <p>Type: <strong>${data.is_multi_slice ? 'Multi-slice' : 'Single-slice'}</strong> DICOM</p>
                            <p>Total Files: ${data.total_files}</p>
                            <p>DICOM Files: ${data.dicom_files}</p>
                            <p>Total Slices: ${data.total_slices}</p>
                            <hr class="border-light">
                            <h6>DICOM Metadata</h6>
                            <p>Modality: ${data.modality}</p>
                            <p>Image Size: ${data.rows} √ó ${data.columns} pixels</p>
                            <p>Bits Allocated: ${data.bits_allocated}</p>
                            <p>Samples per Pixel: ${data.samples_per_pixel}</p>
                            ${data.warning ? `<p class="text-warning">${data.warning}</p>` : ''}
                            <hr class="border-light">
                            <p class="small text-muted">File path: ${data.file_path}</p>
                        </div>
                    `;
                } catch (error) {
                    // Hide spinner
                    spinner.style.display = 'none';
                    
                    console.error('Error checking dataset structure:', error);
                    infoDiv.innerHTML = `
                        <div class="card bg-danger text-light p-3">
                            <h5>Error</h5>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            });
        }

        // Add event listeners to update the threshold value and trigger updateImage on change
        document.getElementById('contour-threshold').addEventListener('input', function() {
            document.getElementById('contour-threshold-value').textContent = this.value;
        });
        document.getElementById('contour-method').addEventListener('change', updateImage);
        document.getElementById('contour-threshold').addEventListener('change', updateImage);

        // Add event listener for the button
        document.getElementById('toggle-contours').addEventListener('click', function() {
            contoursVisible = !contoursVisible;
            this.textContent = contoursVisible ? 'Hide Contours' : 'Show Contours';
            updateImage();
        });

        // Add event listeners to update image on slider change
        function updateCanvasFilter() {
            const brightness = parseInt(document.getElementById('brightness-slider').value, 10);
            const contrast = parseInt(document.getElementById('contrast-slider').value, 10);
            imageCanvas.style.filter = `brightness(${1 + brightness/100}) contrast(${1 + contrast/100})`;
        }

        document.getElementById('brightness-slider').addEventListener('input', function() {
            document.getElementById('brightness-value').textContent = this.value;
            updateCanvasFilter();
        });
        document.getElementById('contrast-slider').addEventListener('input', function() {
            document.getElementById('contrast-value').textContent = this.value;
            updateCanvasFilter();
        });

        // Add event listeners for interpolation controls
        document.getElementById('interpolation-slices').addEventListener('change', function() {
            interpolationSlices = parseInt(this.value) || 0;
            if (contoursVisible) {
                updateImage();
            }
        });

        document.getElementById('toggle-interpolation').addEventListener('click', function() {
            interpolationEnabled = !interpolationEnabled;
            this.textContent = interpolationEnabled ? 'Disable Interpolation' : 'Enable Interpolation';
            if (contoursVisible) {
                updateImage();
            }
        });

        // Initialize the first image
        updateImage();
    }

    // Helper to collect mesh/volume parameters
    function getMeshVolumeParams() {
        return {
            method: document.getElementById('contour-method').value,
            threshold: document.getElementById('contour-threshold').value,
            numInterp: document.getElementById('interpolation-slices').value,
            smooth: document.getElementById('smooth-volume').checked,
            smoothFactor: document.getElementById('smooth-factor').value / 100,
            fillHoles: document.getElementById('fill-holes').checked
        };
    }

    document.getElementById('show-mesh').addEventListener('click', async function() {
        const params = getMeshVolumeParams();
        const url = `/process/mesh/${dsId}?method=${params.method}&threshold=${params.threshold}`;
        const response = await fetch(url);
        const data = await response.json();
        if (data.error) {
            alert(data.error);
            return;
        }
        renderMesh(data.vertices, data.faces);
    });

    // Add color mapping
    const colorMap = {
        blue: new THREE.Color(0.2, 0.6, 1.0),
        red: new THREE.Color(1.0, 0.2, 0.2),
        green: new THREE.Color(0.2, 1.0, 0.2),
        yellow: new THREE.Color(1.0, 1.0, 0.2),
        purple: new THREE.Color(0.8, 0.2, 1.0)
    };

    function renderMesh(vertices, faces) {
        const container = document.getElementById('mesh-viewer');
        container.innerHTML = '';
        console.log('Vertices:', vertices.length, 'Faces:', faces.length);
        if (vertices.length === 0 || faces.length === 0) {
            container.innerHTML = '<div style="color:white;text-align:center;padding:2em;">No mesh data to display.</div>';
            return;
        }
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        container.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const verts = new Float32Array(vertices.flat());
        const indices = new Uint32Array(faces.flat());
        geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        geometry.computeVertexNormals();

        // Center the geometry and get size
        geometry.computeBoundingBox();
        geometry.center();
        const size = geometry.boundingBox.getSize(new THREE.Vector3());
        console.log('Mesh size:', size);

        // Use a basic material for debugging
        const material = new THREE.MeshNormalMaterial({ wireframe: false });
        const mesh = new THREE.Mesh(geometry, material);

        // Auto-scale mesh for visibility
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 100 / maxDim;
        mesh.scale.set(scale, scale, scale);

        scene.add(mesh);

        // Adjust camera position based on mesh size
        camera.position.set(0, 0, maxDim * scale * 1.5 + 50);
        camera.lookAt(0, 0, 0);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 100);
        scene.add(light);

        // Attach OrbitControls to THREE if needed
        if (window.OrbitControls) {
            THREE.OrbitControls = window.OrbitControls;
        }
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    }

    document.getElementById('tool-pen').onclick = () => currentTool = 'pen';
    document.getElementById('tool-rect').onclick = () => currentTool = 'rect';
    document.getElementById('tool-circle').onclick = () => currentTool = 'circle';
    document.getElementById('tool-eraser').onclick = () => currentTool = 'eraser';
    document.getElementById('brush-size').oninput = function() {
        brushSize = parseInt(this.value, 10);
        document.getElementById('brush-size-value').textContent = this.value;
    };
    document.getElementById('brush-color').oninput = function() { brushColor = this.value; };

    function loadPastAnnotations() {
        const ctx = annotationCanvas.getContext('2d');
        let RELATED_RESOURCE_ID = fileIds[idx]
        
        // Construct the URL to load the last annotation
        const url = `/api/annotation/load-last/${RELATED_RESOURCE_ID}`;

        const img = new Image();
        img.onload = function() {
            // Resize canvas if needed
            annotationCanvas.width = img.width;
            annotationCanvas.height = img.height;

            // Draw the annotation image on the annotation canvas
            ctx.clearRect(0, 0, img.width, img.height);
            ctx.drawImage(img, 0, 0);
        };

        img.onerror = function(err) {
            console.error('Failed to load annotation image:', err);
        };

        img.src = url;
    }
    function syncAnnotation() {
        const ctx = annotationCanvas.getContext('2d');

        let RELATED_RESOURCE_ID = fileIds[idx]
        
        // Convert canvas to Blob
        annotationCanvas.toBlob((blob) => {
            const formData = new FormData();
            formData.append("file", blob, "annotation.png");
            formData.append("resource_id", RELATED_RESOURCE_ID);

            fetch("/api/annotation/create", {
                method: "POST",
                body: formData
            })
            .then(response => {
                if (!response.ok) throw new Error("Failed to upload annotation");
                return response.json();
            })
            .then(data => {
                console.log("Annotation saved:", data);
            })
            .catch(error => {
                console.error("Error saving annotation:", error);
            });
        }, "image/png");
    }

    // Helper to save the current annotation state
    function saveAnnotationState() {
        const ctx = annotationCanvas.getContext('2d');
        annotationHistory.push(ctx.getImageData(0, 0, annotationCanvas.width, annotationCanvas.height));
        // Clear redo stack on new action
        redoStack = [];

    }

    // Undo function
    function undoAnnotation() {
        if (annotationHistory.length > 0) {
            const ctx = annotationCanvas.getContext('2d');
            redoStack.push(ctx.getImageData(0, 0, annotationCanvas.width, annotationCanvas.height));
            const prev = annotationHistory.pop();
            ctx.putImageData(prev, 0, 0);
        }
    }

    // Redo function
    function redoAnnotation() {
        if (redoStack.length > 0) {
            const ctx = annotationCanvas.getContext('2d');
            annotationHistory.push(ctx.getImageData(0, 0, annotationCanvas.width, annotationCanvas.height));
            const next = redoStack.pop();
            ctx.putImageData(next, 0, 0);
        }
    }

    // Clear function
    function clearAnnotation() {
        const ctx = annotationCanvas.getContext('2d');
        saveAnnotationState();
        ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    }

    // Wire up the buttons
    document.getElementById('tool-undo').addEventListener('click', undoAnnotation);
    document.getElementById('tool-redo').addEventListener('click', redoAnnotation);
    document.getElementById('tool-clear').addEventListener('click', clearAnnotation);

    // Save state on drawing start
    annotationCanvas.addEventListener('pointerdown', function(e) {
    e.preventDefault(); // Prevent default to avoid scrolling/zooming
    
    if (currentTool === 'pen' || currentTool === 'rect' || currentTool === 'circle' || currentTool === 'eraser') {
        saveAnnotationState();
    }
    
    // Capture the pointer to track it even if it leaves the canvas area
    this.setPointerCapture(e.pointerId);
    
    drawing = true;
    
    // Calculate position relative to canvas
    const rect = annotationCanvas.getBoundingClientRect();
    const scaleX = annotationCanvas.width / rect.width;
    const scaleY = annotationCanvas.height / rect.height;
    
    // Scale the coordinates appropriately (handles high DPI screens better)
    startX = lastX = (e.clientX - rect.left) * scaleX;
    startY = lastY = (e.clientY - rect.top) * scaleY;
    
    if (currentTool === 'pen' || currentTool === 'eraser') {
        const ctx = annotationCanvas.getContext('2d');
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        
        // For mobile, draw a dot on tap to ensure something appears
        ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = currentTool === 'eraser' ? brushSize * 2 : brushSize;
        ctx.lineCap = 'round';
        ctx.arc(startX, startY, 0.5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(startX, startY);
    }
});

annotationCanvas.addEventListener('pointermove', function(e) {
    if (!drawing) return;
    
    // Calculate position with proper scaling
    const rect = annotationCanvas.getBoundingClientRect();
    const scaleX = annotationCanvas.width / rect.width;
    const scaleY = annotationCanvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const ctx = annotationCanvas.getContext('2d');
    
    if (currentTool === 'pen') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
    } else if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = brushSize * 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
    } else if (currentTool === 'rect' || currentTool === 'circle') {
        // Optional: preview of shape while drawing
        // Requires saving and restoring canvas between moves
    }
    
    lastX = x;
    lastY = y;
});

annotationCanvas.addEventListener('pointerup', function(e) {
    if (!drawing) return;
    
    drawing = false;
    
    // Calculate final position with proper scaling
    const rect = annotationCanvas.getBoundingClientRect();
    const scaleX = annotationCanvas.width / rect.width;
    const scaleY = annotationCanvas.height / rect.height;
    
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    const ctx = annotationCanvas.getContext('2d');
    
    if (currentTool === 'rect') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        ctx.strokeRect(startX, startY, x - startX, y - startY);
    } else if (currentTool === 'circle') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
        ctx.beginPath();
        ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
        ctx.stroke();
    }
    
    ctx.globalCompositeOperation = 'source-over';
    ctx.beginPath();
    
    // Sync annotation to server
    syncAnnotation();
    
    // Release pointer capture
    this.releasePointerCapture(e.pointerId);
});

annotationCanvas.addEventListener('pointercancel', function(e) {
    if (!drawing) return;
    
    drawing = false;
    
    try {
        // Make sure we have a valid pointerId before releasing
        if (e && e.pointerId) {
            this.releasePointerCapture(e.pointerId);
        }
    } catch (err) {
        console.log('Error releasing pointer capture:', err);
    }
    
    const ctx = annotationCanvas.getContext('2d');
    ctx.beginPath();
});

// Add these additional event listeners for better mobile support
annotationCanvas.addEventListener('touchstart', function(e) {
    e.preventDefault(); // Prevent scrolling and zooming
}, { passive: false });

annotationCanvas.addEventListener('touchmove', function(e) {
    e.preventDefault(); // Prevent scrolling and zooming
}, { passive: false });

// Prevent scrolling when touching the canvas
document.body.addEventListener('touchstart', function(e) {
    if (e.target === annotationCanvas) {
        e.preventDefault();
    }
}, { passive: false });

// Optional: Add this function to handle window resizing
window.addEventListener('resize', function() {
    // Resize canvas elements properly
    const imageWidth = imageCanvas.width;
    const imageHeight = imageCanvas.height;
    
    // Update wrapper dimensions to match screen size while maintaining aspect ratio
    const wrapper = imageCanvas.parentElement;
    const maxWidth = wrapper.parentElement.clientWidth * 0.95; // 95% of container width
    
    let newWidth = imageWidth;
    let newHeight = imageHeight;
    
    if (newWidth > maxWidth) {
        const ratio = maxWidth / newWidth;
        newWidth = maxWidth;
        newHeight = imageHeight * ratio;
    }
    
    wrapper.style.width = newWidth + 'px';
    wrapper.style.height = newHeight + 'px';
    
    // Update canvas display sizes (not pixel dimensions)
    imageCanvas.style.width = annotationCanvas.style.width = newWidth + 'px';
    imageCanvas.style.height = annotationCanvas.style.height = newHeight + 'px';
});

    document.getElementById('export-stl').addEventListener('click', function() {
        const params = getMeshVolumeParams();
        const url = `/process/export-volume/${dsId}?` + new URLSearchParams({
            method: params.method,
            threshold: params.threshold,
            num_interp: params.numInterp,
            smooth: params.smooth,
            smooth_factor: params.smoothFactor,
            fill_holes: params.fillHoles
        });
        window.location.href = url;
    });

    document.getElementById('reconstruct-volume').addEventListener('click', async function() {
        const params = getMeshVolumeParams();
        try {
            const response = await fetch(`/process/volume/${dsId}?` + new URLSearchParams({
                method: params.method,
                threshold: params.threshold,
                num_interp: params.numInterp,
                smooth: params.smooth,
                smooth_factor: params.smoothFactor,
                fill_holes: params.fillHoles
            }));
            const data = await response.json();
            if (data.error) {
                alert(data.error);
                return;
            }
            renderMesh(data.vertices, data.faces, data.volume_shape);
        } catch (error) {
            console.error('Error reconstructing volume:', error);
            alert('Failed to reconstruct volume');
        }
    });
});
</script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
{% endblock %}
