{% extends 'base.html' %}

{% block title %}Dataset ‚Äì {{ dataset.name }}{% endblock %}

{% block content %}
<div class="dashboard-header mb-4">
  <h1 class="mb-2">{{ dataset.name }}</h1>
  {% if dataset.description %}
    <p class="text-secondary">{{ dataset.description }}</p>
  {% endif %}
  <p>Status: <span class="fw-bold text-info">{{ dataset.tags }}</span></p>
  <div id="image-controls" class="d-flex flex-row align-items-center gap-3 mt-3" style="background:#23272b; border-radius:8px; padding:12px;">
    <label class="text-light mb-0" for="brightness-slider">Brightness</label>
    <input type="range" id="brightness-slider" min="-100" max="100" value="0" style="width:120px;">
    <span id="brightness-value" class="text-light">0</span>
    <label class="text-light mb-0 ms-3" for="contrast-slider">Contrast</label>
    <input type="range" id="contrast-slider" min="-100" max="100" value="0" style="width:120px;">
    <span id="contrast-value" class="text-light">0</span>
  </div>
  <div id="drawing-tools" class="d-flex flex-row align-items-center gap-3 mt-3" style="background:#23272b; border-radius:8px; padding:12px;">
    <button class="btn btn-outline-light btn-sm" id="tool-pen" title="Freehand">‚úèÔ∏è Pen</button>
    <button class="btn btn-outline-light btn-sm" id="tool-rect" title="Rectangle">‚ñ≠ Rect</button>
    <button class="btn btn-outline-light btn-sm" id="tool-circle" title="Circle">‚óØ Circle</button>
    <button class="btn btn-outline-light btn-sm" id="tool-eraser" title="Eraser">üßΩ Eraser</button>
    <label class="text-light mb-0 ms-3" for="brush-size">Brush Size</label>
    <input type="range" id="brush-size" min="1" max="30" value="5" style="width:100px;">
    <span id="brush-size-value" class="text-light">5</span>
    <label class="text-light mb-0 ms-3" for="brush-color">Color</label>
    <input type="color" id="brush-color" value="#00ff00" style="width: 30px; height: 30px;">
    <button class="btn btn-outline-warning btn-sm ms-3" id="tool-undo" title="Undo">‚Ü©Ô∏è Undo</button>
    <button class="btn btn-outline-warning btn-sm" id="tool-redo" title="Redo">‚Ü™Ô∏è Redo</button>
    <button class="btn btn-outline-danger btn-sm" id="tool-clear" title="Clear">üóëÔ∏è Clear</button>
  </div>
</div>

<!-- Editor Section -->
<div class="editor-container d-flex flex-column align-items-center my-4">
  <div class="editor-toolbar mb-2"></div>
  <div class="editor-wrapper card bg-secondary bg-gradient p-3" style="position:relative;">
    <canvas id="image-canvas" style="position:absolute; top:0; left:0; z-index:1; width:100%; height:100%;"></canvas>
    <canvas id="annotation-canvas" style="position:absolute; top:0; left:0; z-index:2; width:100%; height:100%;"></canvas>
  </div>
</div>

<p class="text-center text-light">
  Image <span id="current-index">1</span> of {{ files|length }}
  {% if files and files[0].mime == 'application/dicom' %}
  | Slice <span id="current-slice">1</span> of <span id="total-slices">1</span>
  {% endif %}
</p>

<!-- Slim, professional toolbar -->
<div class="d-flex flex-wrap justify-content-center align-items-center gap-3 py-2 mb-3" style="background: #23272b; border-radius: 0.5rem;">
  <div class="btn-group me-2" role="group" aria-label="Navigation">
    <button id="prev" class="btn btn-outline-light btn-sm" title="Previous Image">‚óÄ</button>
    <button id="next" class="btn btn-outline-light btn-sm" title="Next Image">‚ñ∂</button>
    <button id="prev-slice" class="btn btn-outline-light btn-sm" title="Previous Slice">‚Üë</button>
    <button id="next-slice" class="btn btn-outline-light btn-sm" title="Next Slice">‚Üì</button>
  </div>
  <div class="d-flex align-items-center gap-2">
    <label class="text-light mb-0" for="contour-method" style="font-size: 0.95em;">Contour:</label>
    <select id="contour-method" class="form-select form-select-sm w-auto">
      <option value="adaptive">Adaptive</option>
      <option value="canny">Canny</option>
      <option value="manual">Manual Threshold</option>
      <option value="otsu">Otsu</option>
    </select>
  </div>
  <div class="d-flex align-items-center gap-2">
    <label class="text-light mb-0" for="contour-threshold" style="font-size: 0.95em;">Threshold:</label>
    <input type="range" id="contour-threshold" min="0" max="255" value="50" class="form-range w-auto" style="width:120px;">
    <span id="contour-threshold-value" class="text-light ms-1" style="font-size: 0.95em;">50</span>
  </div>
  <button id="toggle-contours" class="btn btn-outline-info btn-sm ms-2">Hide Contours</button>
</div>

<!-- Edit Controls -->
<div id="edit-controls" class="mt-4">
  <form id="batch-filter-form" method="POST" action="{{ url_for('processing.batch_apply', ds_id=dataset.id) }}" class="d-flex flex-wrap gap-2 justify-content-center mb-3">
    {% for name in filter_names %}
      <button type="submit" name="filter_name" value="{{ name }}" class="btn btn-outline-info">{{ name }}</button>
    {% endfor %}
  </form>
  <div class="d-flex gap-2 justify-content-center align-items-center mb-2">
    <a href="{{ url_for('processing.batch_undo', ds_id=dataset.id) }}" class="btn btn-outline-warning">Undo All</a>
    <a href="{{ url_for('processing.batch_reset', ds_id=dataset.id) }}" class="btn btn-outline-danger">Reset All</a>
    <a href="{{ url_for('processing.batch_download', ds_id=dataset.id) }}" class="btn btn-outline-success">Download All</a>
    {% if files and files[0].mime == 'application/dicom' %}
    <button id="check-structure" class="btn btn-outline-info">Check Dataset Structure</button>
    {% endif %}
  </div>
  {% if processes %}
    <p class="mt-3"><strong>Applied Filters:</strong> <span class="text-info">{{ processes | join(' ‚Üí ') }}</span></p>
  {% endif %}
  <div id="dataset-structure-info" class="mt-3 text-center" style="display: none;">
      <div class="spinner-border text-info" role="status" style="display: none;">
          <span class="visually-hidden">Loading...</span>
      </div>
  </div>
</div>

<div id="mesh-viewer" style="width: 600px; height: 400px; margin: 0 auto; background: #111; border-radius: 0.5rem;"></div>
<button id="show-mesh" class="btn btn-outline-info btn-sm mt-2">Show 3D Mesh</button>

<script type="module">
import { CursorManager } from "{{ url_for('static', filename='js/editor/CursorManager.js') }}";

document.addEventListener('DOMContentLoaded', function() {
    // Always output a valid JS array
    const fileIds = {{ files|default([])|map(attribute='id')|list|tojson }};
    let idx = 0;
    const currentIndexEl = document.getElementById('current-index');
    const currentSliceEl = document.getElementById('current-slice');
    const totalSlicesEl = document.getElementById('total-slices');
    const total = fileIds.length;
    const toolbarEl = document.querySelector('.editor-toolbar');
    const imageCanvas = document.getElementById('image-canvas');
    const annotationCanvas = document.getElementById('annotation-canvas');
    const filterForm = document.getElementById('batch-filter-form');
    let contoursVisible = true;
    let currentTool = 'pen';
    let brushSize = 5;
    let brushColor = '#00ff00';
    let drawing = false;
    let startX = 0, startY = 0;
    let lastX = 0, lastY = 0;

    function loadImageToCanvas(imageUrl, imageCanvas, annotationCanvas, callback) {
        console.log('Loading image from URL:', imageUrl);  // Debug log
        const img = new window.Image();
        img.onload = function() {
            console.log('Image loaded successfully');  // Debug log
            // Set wrapper size to match image
            const wrapper = imageCanvas.parentElement;
            wrapper.style.width = img.width + 'px';
            wrapper.style.height = img.height + 'px';

            // Set canvas pixel size to match image
            imageCanvas.width = img.width;
            imageCanvas.height = img.height;
            annotationCanvas.width = img.width;
            annotationCanvas.height = img.height;

            imageCanvas.style.width = annotationCanvas.style.width = img.width + 'px';
            imageCanvas.style.height = annotationCanvas.style.height = img.height + 'px';

            imageCanvas.getContext('2d').clearRect(0, 0, img.width, img.height);
            imageCanvas.getContext('2d').drawImage(img, 0, 0);
            annotationCanvas.getContext('2d').clearRect(0, 0, img.width, img.height);
            if (callback) callback();
        };
        img.onerror = function(error) {
            console.error('Failed to load image:', imageUrl, error);  // Debug log
            // Show error message on canvas
            const ctx = imageCanvas.getContext('2d');
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.fillStyle = '#dc3545';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Failed to load image', imageCanvas.width/2, imageCanvas.height/2);
        };
        img.src = imageUrl;
    }

    if (total > 0) {
        async function fetchDicomInfo(fileId) {
            try {
                const response = await fetch(`{{ url_for('processing.dicom_info', file_id=0) }}`.replace('0', fileId));
                if (!response.ok) throw new Error('Failed to fetch DICOM info');
                const data = await response.json();
                if (data.error) throw new Error(data.error);
                return data;
            } catch (error) {
                console.error('Error fetching DICOM info:', error);
                return { total_slices: 1 };
            }
        }

        async function updateImage() {
            const imageUrl = `{{ url_for('processing.image', file_id=0) }}`.replace('0', fileIds[idx]);
            console.log('Updating image with URL:', imageUrl);  // Debug log
            currentIndexEl.textContent = idx + 1;
            toolbarEl.innerHTML = '';
            
            // Check if the first file is a DICOM file by checking its extension
            const firstFile = {{ files[0].path|tojson|safe }};
            const isDicom = firstFile.toLowerCase().endsWith('.dcm');
            console.log('First file:', firstFile);  // Debug log
            console.log('Is DICOM:', isDicom);  // Debug log
            
            if (isDicom) {
                // Fetch DICOM info for the current file
                const dicomInfo = await fetchDicomInfo(fileIds[idx]);
                if (totalSlicesEl) totalSlicesEl.textContent = dicomInfo.total_slices || total;
                if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            }
            
            // Load image and reset annotation canvas
            loadImageToCanvas(imageUrl, imageCanvas, annotationCanvas, async function() {
                // Set up drawing tools on annotationCanvas only
                const imageManager = {
                    getContext: () => annotationCanvas.getContext('2d'),
                    getCanvas: () => annotationCanvas,
                    getRegions: () => [], // You can implement region tracking if needed
                    addRegion: () => {},
                };
                const cursorManager = CursorManager(imageManager);
                toolbarEl.innerHTML = ""; // Clear previous buttons
                toolbarEl.appendChild(cursorManager.getElement());
                cursorManager.bindCanvas(annotationCanvas);

                // --- Draw contours ---
                if (contoursVisible) {
                    await drawExtendedContours(idx, annotationCanvas);
                }
            });
        }

        async function drawExtendedContours(idx, annotationCanvas) {
            const ctx = annotationCanvas.getContext('2d');
            ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            const method = document.getElementById('contour-method')?.value || 'adaptive';
            const threshold = document.getElementById('contour-threshold')?.value || 50;
            // Helper to fetch and draw contours
            async function fetchAndDrawContours(sliceIdx, color, width, alpha=1.0) {
                if (sliceIdx < 0 || sliceIdx >= fileIds.length) return;
                let url = `/process/contours/${fileIds[sliceIdx]}?method=${method}`;
                if (method === 'manual') url += `&threshold=${threshold}`;
                const data = await (await fetch(url)).json();
                ctx.save();
                ctx.strokeStyle = color;
                ctx.globalAlpha = alpha;
                ctx.lineWidth = width;
                data.contours.forEach(contour => {
                    if (contour.length < 2) return;
                    ctx.beginPath();
                    ctx.moveTo(contour[0][0], contour[0][1]);
                    for (let i = 1; i < contour.length; i++) {
                        ctx.lineTo(contour[i][0], contour[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            // Draw previous slice contours (faded blue)
            await fetchAndDrawContours(idx - 1, 'rgba(0,0,255,0.5)', 1, 0.5);
            // Draw next slice contours (faded red)
            await fetchAndDrawContours(idx + 1, 'rgba(255,0,0,0.5)', 1, 0.5);
            // Draw current slice contours (lime, normal)
            await fetchAndDrawContours(idx, 'lime', 2, 1.0);
        }

        // Handle slice navigation
        if (document.getElementById('prev-slice')) {
            document.getElementById('prev-slice').addEventListener('click', function() {
                if (idx > 0) {
                    idx--;
                    if (currentSliceEl) currentSliceEl.textContent = idx + 1;
                    console.log('Previous slice:', idx + 1);  // Debug log
                    updateImage();
                }
            });

            document.getElementById('next-slice').addEventListener('click', function() {
                if (idx < total - 1) {
                    idx++;
                    if (currentSliceEl) currentSliceEl.textContent = idx + 1;
                    console.log('Next slice:', idx + 1);  // Debug log
                    updateImage();
                }
            });
        }

        document.getElementById('prev').addEventListener('click', function() {
            idx = (idx - 1 + total) % total;
            if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            updateImage();
        });

        document.getElementById('next').addEventListener('click', function() {
            idx = (idx + 1) % total;
            if (currentSliceEl) currentSliceEl.textContent = idx + 1;
            updateImage();
        });

        // Handle filter form submission
        filterForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData();
            const filterName = e.submitter.value; // Get the value from the clicked button
            formData.append('filter_name', filterName);
            
            fetch(this.action, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the processes list if it exists
                    const processesEl = document.querySelector('#edit-controls p');
                    if (processesEl) {
                        processesEl.innerHTML = `<strong>Applied Filters:</strong> ${data.processes.join(' ‚Üí ')}`;
                    }
                    
                    // Add a timestamp to force image reload
                    const timestamp = new Date().getTime();
                    const imageUrl = `{{ url_for('processing.image', file_id=0) }}`.replace('0', fileIds[idx]);
                    const finalUrl = `${imageUrl}?t=${timestamp}`;
                    
                    // Reload the current image to show the applied filter
                    loadImageToCanvas(finalUrl, imageCanvas, annotationCanvas, function() {
                        // Set up drawing tools on annotationCanvas only
                        const imageManager = {
                            getContext: () => annotationCanvas.getContext('2d'),
                            getCanvas: () => annotationCanvas,
                            getRegions: () => [], // You can implement region tracking if needed
                            addRegion: () => {},
                        };
                        const cursorManager = CursorManager(imageManager);
                        toolbarEl.innerHTML = ""; // Clear previous buttons
                        toolbarEl.appendChild(cursorManager.getElement());
                        cursorManager.bindCanvas(annotationCanvas);
                    });
                } else {
                    console.error('Failed to apply filter:', data.message);
                }
            })
            .catch(error => {
                console.error('Error applying filter:', error);
            });
        });

        // Add dataset structure check
        const checkStructureBtn = document.getElementById('check-structure');
        if (checkStructureBtn) {
            checkStructureBtn.addEventListener('click', async function() {
                const infoDiv = document.getElementById('dataset-structure-info');
                const spinner = infoDiv.querySelector('.spinner-border');
                
                try {
                    // Show loading spinner
                    infoDiv.style.display = 'block';
                    spinner.style.display = 'inline-block';
                    infoDiv.innerHTML = ''; // Clear previous content
                    infoDiv.appendChild(spinner);
                    
                    const response = await fetch(`{{ url_for('processing.dataset_info', ds_id=dataset.id) }}`);
                    const data = await response.json();
                    
                    // Hide spinner
                    spinner.style.display = 'none';
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to fetch dataset info');
                    }
                    
                    if (data.error) {
                        infoDiv.innerHTML = `
                            <div class="card bg-danger text-light p-3">
                                <h5>Error</h5>
                                <p>${data.error}</p>
                                ${data.file_path ? `<p class="small">File path: ${data.file_path}</p>` : ''}
                            </div>
                        `;
                        return;
                    }
                    
                    infoDiv.innerHTML = `
                        <div class="card bg-secondary text-light p-3">
                            <h5>Dataset Structure Information</h5>
                            <p>Type: <strong>${data.is_multi_slice ? 'Multi-slice' : 'Single-slice'}</strong> DICOM</p>
                            <p>Total Files: ${data.total_files}</p>
                            <p>DICOM Files: ${data.dicom_files}</p>
                            <p>Total Slices: ${data.total_slices}</p>
                            <hr class="border-light">
                            <h6>DICOM Metadata</h6>
                            <p>Modality: ${data.modality}</p>
                            <p>Image Size: ${data.rows} √ó ${data.columns} pixels</p>
                            <p>Bits Allocated: ${data.bits_allocated}</p>
                            <p>Samples per Pixel: ${data.samples_per_pixel}</p>
                            ${data.warning ? `<p class="text-warning">${data.warning}</p>` : ''}
                            <hr class="border-light">
                            <p class="small text-muted">File path: ${data.file_path}</p>
                        </div>
                    `;
                } catch (error) {
                    // Hide spinner
                    spinner.style.display = 'none';
                    
                    console.error('Error checking dataset structure:', error);
                    infoDiv.innerHTML = `
                        <div class="card bg-danger text-light p-3">
                            <h5>Error</h5>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            });
        }

        // Add event listeners to update the threshold value and trigger updateImage on change
        document.getElementById('contour-threshold').addEventListener('input', function() {
            document.getElementById('contour-threshold-value').textContent = this.value;
        });
        document.getElementById('contour-method').addEventListener('change', updateImage);
        document.getElementById('contour-threshold').addEventListener('change', updateImage);

        // Add event listener for the button
        document.getElementById('toggle-contours').addEventListener('click', function() {
            contoursVisible = !contoursVisible;
            this.textContent = contoursVisible ? 'Hide Contours' : 'Show Contours';
            updateImage();
        });

        // Add event listeners to update image on slider change
        function updateCanvasFilter() {
            const brightness = parseInt(document.getElementById('brightness-slider').value, 10);
            const contrast = parseInt(document.getElementById('contrast-slider').value, 10);
            imageCanvas.style.filter = `brightness(${1 + brightness/100}) contrast(${1 + contrast/100})`;
        }

        document.getElementById('brightness-slider').addEventListener('input', function() {
            document.getElementById('brightness-value').textContent = this.value;
            updateCanvasFilter();
        });
        document.getElementById('contrast-slider').addEventListener('input', function() {
            document.getElementById('contrast-value').textContent = this.value;
            updateCanvasFilter();
        });

        // Initialize the first image
        updateImage();
    }

    document.getElementById('show-mesh').addEventListener('click', async function() {
        const dsId = {{ dataset.id }};
        const method = document.getElementById('contour-method').value;
        const threshold = document.getElementById('contour-threshold').value;
        const url = `/process/mesh/${dsId}?method=${method}&threshold=${threshold}`;
        const response = await fetch(url);
        const data = await response.json();
        if (data.error) {
            alert(data.error);
            return;
        }
        renderMesh(data.vertices, data.faces);
    });

    function renderMesh(vertices, faces) {
        const container = document.getElementById('mesh-viewer');
        container.innerHTML = '';
        console.log('Vertices:', vertices.length, 'Faces:', faces.length);
        if (vertices.length === 0 || faces.length === 0) {
            container.innerHTML = '<div style="color:white;text-align:center;padding:2em;">No mesh data to display.</div>';
            return;
        }
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        container.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const verts = new Float32Array(vertices.flat());
        const indices = new Uint32Array(faces.flat());
        geometry.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        geometry.computeVertexNormals();

        // Center the geometry and get size
        geometry.computeBoundingBox();
        geometry.center();
        const size = geometry.boundingBox.getSize(new THREE.Vector3());
        console.log('Mesh size:', size);

        // Use a basic material for debugging
        const material = new THREE.MeshNormalMaterial({ wireframe: false });
        const mesh = new THREE.Mesh(geometry, material);

        // Auto-scale mesh for visibility
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 100 / maxDim;
        mesh.scale.set(scale, scale, scale);

        scene.add(mesh);

        // Adjust camera position based on mesh size
        camera.position.set(0, 0, maxDim * scale * 1.5 + 50);
        camera.lookAt(0, 0, 0);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 100);
        scene.add(light);

        // Attach OrbitControls to THREE if needed
        if (window.OrbitControls) {
            THREE.OrbitControls = window.OrbitControls;
        }
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    }

    document.getElementById('tool-pen').onclick = () => currentTool = 'pen';
    document.getElementById('tool-rect').onclick = () => currentTool = 'rect';
    document.getElementById('tool-circle').onclick = () => currentTool = 'circle';
    document.getElementById('tool-eraser').onclick = () => currentTool = 'eraser';
    document.getElementById('brush-size').oninput = function() {
        brushSize = parseInt(this.value, 10);
        document.getElementById('brush-size-value').textContent = this.value;
    };
    document.getElementById('brush-color').oninput = function() { brushColor = this.value; };

    annotationCanvas.addEventListener('mousedown', function(e) {
        drawing = true;
        const rect = annotationCanvas.getBoundingClientRect();
        startX = lastX = e.clientX - rect.left;
        startY = lastY = e.clientY - rect.top;
        if (currentTool === 'pen' || currentTool === 'eraser') {
            const ctx = annotationCanvas.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(startX, startY);
        }
    });

    annotationCanvas.addEventListener('mousemove', function(e) {
        if (!drawing) return;
        const rect = annotationCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const ctx = annotationCanvas.getContext('2d');
        if (currentTool === 'pen') {
            ctx.strokeStyle = brushColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        } else if (currentTool === 'eraser') {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = brushSize * 2;
            ctx.lineCap = 'round';
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }
        lastX = x;
        lastY = y;
    });

    annotationCanvas.addEventListener('mouseup', function(e) {
        if (!drawing) return;
        drawing = false;
        const rect = annotationCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const ctx = annotationCanvas.getContext('2d');
        if (currentTool === 'rect') {
            ctx.strokeStyle = brushColor;
            ctx.lineWidth = brushSize;
            ctx.strokeRect(startX, startY, x - startX, y - startY);
        } else if (currentTool === 'circle') {
            ctx.strokeStyle = brushColor;
            ctx.lineWidth = brushSize;
            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
            ctx.beginPath();
            ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        ctx.beginPath();
    });

    annotationCanvas.addEventListener('mouseleave', function() {
        drawing = false;
        annotationCanvas.getContext('2d').beginPath();
    });
});
</script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
{% endblock %}
